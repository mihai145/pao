package model.exchange;

import database.DatabaseConnection;
import exceptions.NoDataFoundForCompanyException;
import model.company.Company;
import model.exchange.ordercomparator.InverseOrderComparator;
import model.exchange.ordercomparator.OrderComparator;
import model.order.Order;
import model.order.OrderAction;

import java.sql.SQLException;
import java.util.*;

public class Exchange {
    public String name;
    HashMap<String, PriorityQueue<Order>> buyOrders;
    HashMap<String, PriorityQueue<Order>> sellOrders;
    HashMap<String, ArrayList<Transaction>> transactionsFor;

    public Exchange(String name) {
        this.name = name;
        buyOrders = new HashMap<>();
        sellOrders = new HashMap<>();
        transactionsFor = new HashMap<>();
    }

    public String getName() {
        return name;
    }

    // get all the transactions on this exchange for a given company
    public ArrayList<Transaction> getTransactionsFor(String ticker) {
        if (!transactionsFor.containsKey(ticker)) return new ArrayList<>();
        return transactionsFor.get(ticker);
    }

    // add an order
    public void addOrder(Order order) throws SQLException {
        // place an order in the buy queue or the sell queue
        if (order.getOrderAction() == OrderAction.BUY) {
            if (!buyOrders.containsKey(order.getTicker())) {
                buyOrders.put(order.getTicker(), new PriorityQueue<>(new OrderComparator()));
            }
            buyOrders.get(order.getTicker()).add(order);
        } else {
            if (!sellOrders.containsKey(order.getTicker())) {
                sellOrders.put(order.getTicker(), new PriorityQueue<>(new InverseOrderComparator()));
            }
            sellOrders.get(order.getTicker()).add(order);
        }

        // match the order, if it is possible
        match(order.getTicker(), order.getOrderAction());
    }

    // performs order-book matching for a given company
    private void match(String ticker, OrderAction oa) throws SQLException {
        if (!buyOrders.containsKey(ticker) || !sellOrders.containsKey(ticker)) return;

        // match as long as the current price is better than the outstanding price
        // ie if the buy order has a higher price than the sell order
        while (buyOrders.get(ticker).size() > 0 && sellOrders.get(ticker).size() > 0) {
            Order buyOrder = buyOrders.get(ticker).peek(), sellOrder = sellOrders.get(ticker).peek();
            if (buyOrder != null && sellOrder != null && buyOrder.getPrice() >= sellOrder.getPrice()) {
                // remove orders from the order book
                buyOrders.get(ticker).poll();
                sellOrders.get(ticker).poll();

                // calculate matched price and quantity; generate a transaction
                double price = (oa == OrderAction.BUY) ? sellOrder.getPrice() : buyOrder.getPrice();
                int quantity = Math.min(sellOrder.getQuantity(), buyOrder.getQuantity());
                addTransaction(ticker, sellOrder.getStockTrader().getName(), buyOrder.getStockTrader().getName(), price, quantity);

                // deduct the matched quantity from both orders; reinsert them in the order book if they are not fulfilled
                buyOrder.deductQuantity(quantity);
                sellOrder.deductQuantity(quantity);
                if (buyOrder.getQuantity() > 0) {
                    buyOrders.get(ticker).add(buyOrder);
                } else {
                    buyOrder.notifyCompleted();
                }
                if (sellOrder.getQuantity() > 0) {
                    sellOrders.get(ticker).add(sellOrder);
                } else {
                    sellOrder.notifyCompleted();
                }
            } else {
                break;
            }
        }
    }

    // add a transaction generated by matching
    private void addTransaction(String ticker, String from, String to, double price, int quantity) throws SQLException {
        // add the current timestamp to the transaction
        Date date = new Date();
        java.sql.Date sqlDate = new java.sql.Date(date.getTime());
        DatabaseConnection.getInstance().addTransaction(name, ticker, sqlDate, from, to, price, quantity);

        if (!transactionsFor.containsKey(ticker)) transactionsFor.put(ticker, new ArrayList<>());
        transactionsFor.get(ticker).add(new Transaction(date, from, to, price, quantity));
    }

    // add a transaction generated by a database state restoration
    // the timestamp of the transaction is retrieved from the database
    public void addTransaction(String ticker, String from, String to, Date date, double price, int quantity) {
        if (!transactionsFor.containsKey(ticker)) transactionsFor.put(ticker, new ArrayList<>());
        transactionsFor.get(ticker).add(new Transaction(date, from, to, price, quantity));
    }

    // cancel an order
    public void cancel(Order order) {
        if (order.getOrderAction() == OrderAction.BUY) {
            buyOrders.get(order.getTicker()).remove(order);
        } else {
            sellOrders.get(order.getTicker()).remove(order);
        }
    }

    // show transactions for a given company
    public void showTransactions(Company c) {
        if (!c.isListedOn(this)) {
            System.out.println("model.Company.Company " + c.getName() + " is not listed on " + name);
            return;
        }

        if (!transactionsFor.containsKey(c.getTicker())) {
            System.out.println("No transactions for " + c.getName() + " on " + name);
            return;
        }

        ArrayList<Transaction> list = transactionsFor.get(c.getTicker());
        for (int i = 0; i < list.size(); i++) {
            System.out.println((i + 1) + ". " + list.get(i).toString());
        }
    }

    // show active orders for a given company
    public void showOrders(Company c) {
        // show buy orders
        if (!buyOrders.containsKey(c.getTicker()) || buyOrders.get(c.getTicker()).size() == 0) {
            System.out.println("No buy orders for " + c.getName() + " on " + name);
        } else {
            System.out.println("Buy orders for " + c.getName() + " on " + name + ":");

            buyOrders.get(c.getTicker())
                    .forEach(Order::displayOnExchange);
        }

        // show sell orders
        if (!sellOrders.containsKey(c.getTicker()) || sellOrders.get(c.getTicker()).size() == 0) {
            System.out.println("No sell orders for " + c.getName() + " on " + name);
        } else {
            System.out.println("Sell orders for " + c.getName() + " on " + name + ":");

            sellOrders.get(c.getTicker())
                    .forEach(Order::displayOnExchange);
        }
    }

    // get the market price for buying or selling a given company
    public double getMarketPrice(OrderAction oa, String ticker) throws NoDataFoundForCompanyException {
        // buy case
        if (oa == OrderAction.BUY) {
            if (!buyOrders.containsKey(ticker) || buyOrders.get(ticker).size() == 0) {
                throw new NoDataFoundForCompanyException("No data found for " + ticker);
            }
            return Objects.requireNonNull(buyOrders.get(ticker).peek()).getPrice();
        }

        // sell case
        if (!sellOrders.containsKey(ticker) || sellOrders.get(ticker).size() == 0) {
            throw new NoDataFoundForCompanyException("No data found for " + ticker);
        }
        return Objects.requireNonNull(sellOrders.get(ticker).peek()).getPrice();
    }
}
